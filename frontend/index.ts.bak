import { encode, decode, decodeAsync } from "@msgpack/msgpack";
import * as d3 from "d3";
import { sliderBottom } from "d3-simple-slider";

import "./style.scss";

const NO_CHOSEN_NODE = "None";

const state: {
  availableNodes: string[];
  chosenNode: string;
  id2param: { [id: number]: AnyParam };
  id2paramEditor: { [id: number]: ParamEditor<AnyParam> };
  telemLinks: string[];
} = {
  availableNodes: [],
  chosenNode: NO_CHOSEN_NODE,
  id2param: {},
  id2paramEditor: {},
  telemLinks: [],
};

const nodePicker = document.getElementById("nodes") as HTMLSelectElement;
nodePicker.oninput = (e) =>
  setChosenNode((e.target as HTMLSelectElement).value);

const interfaceDiv = d3.select("#interface");
const telemetryLinks = d3.select("#telem");
const tunerDiv = d3.select("#tuner");

ws.onmessage = async ({ data }) => {
  try {
    // check first to see if this is a json message with an updated availableNodes
    console.log("data", data);
    const { availableNodes } = JSON.parse(data);
    console.log("got available nodes", availableNodes);
    setAvailableNodes(availableNodes);

    // conect to the first available node
    // TODO: do better here
    setChosenNode(availableNodes[0]);

    if (!state.availableNodes.includes(state.chosenNode)) {
      setChosenNode(NO_CHOSEN_NODE);
    }
  } catch (err) {
    if (err instanceof SyntaxError) {
      const msg: any = await decodeFromBlob(data);
      console.log("got msgpack msg", msg);

      // if we're awaiting param definitions
      if ("params" in msg) {
        setParams(msg["params"] as AnyParam[]);
        setTelemLinks(msg["telemLinks"]);
      } else if (Array.isArray(msg)) {
        // gui reconstruction callback]
        const params = msg as AnyParam[];
        updateID2Param(params);

        for (const def of msg as AnyParam[]) {
          const editor = state.id2paramEditor[def.id];
          editor.param = def;
          editor.reconstructGui();
        }
      } else {
        console.error(
          "unexpected msg from server:",
          msg,
          "while in state",
          state
        );
        debugger;
      }
    }
  }
};

function setAvailableNodes(newNodes: string[]) {
  nodePicker.innerHTML = [...newNodes, NO_CHOSEN_NODE]
    .map((node) => `<option value="${node}">${node}</option>`)
    .join("");
  nodePicker.value = state.chosenNode;
  state.availableNodes = newNodes;
}

function setChosenNode(chosenNode: string) {
  // if it actually changed
  if (state.chosenNode !== chosenNode) {
    state.chosenNode = chosenNode;
    nodePicker.value = state.chosenNode;

    ws.send(JSON.stringify({ chosenNode }));

    setParams([]); // clear existing param id2paramEditor
  }
}

function setParams(params: AnyParam[]) {
  state.id2param = {};
  updateID2Param(params);

  interfaceDiv.style("display", params.length > 0 ? "block" : "none");

  tunerDiv
    .selectAll("*")
    .remove()
    .data(params) // populate with new controls
    .enter()
    .append((param: AnyParam): any => createParamControl(param).el.node());
}

function updateID2Param(params: AnyParam[]) {
  for (const param of params) {
    state.id2param[param.id] = param;
    if ("params" in param) {
      // recurse through hyperparameters
      updateID2Param(Object.values(param.params));
    }
  }
}

function createParamControl(param: AnyParam) {
  const editor =
    

  if (!editor) {
    console.error(param);
    throw new Error(`no editor found for param ^`);
  }
  return editor;
}

type D3Div = d3.Selection<HTMLDivElement, unknown, HTMLElement, undefined>;

abstract class ParamEditor<T extends Param<any>> {
  param: T;
  el: D3Div;

  constructor(param: T, insertLabel = true) {
    this.param = param;
    this.el = d3.create("div").classed("param-editor", true);
    if (insertLabel) {
      this.el.append("label").html(param.name.replace(" ", "<br />"));
    }
    state.id2paramEditor[param.id] = this;
    this.setup();
  }

  setParamVal(val: T["val"]) {
    this.param.val = val;
    // TODO: send value update over websocket
    ws.send(encode([this.param.id, val]));
    console.log("setting param", this.param, "to val", val);
  }

  // modify element to reflect new value
  // TODO: make abstract once impld
  onParamChange(val: T): void {}

  reconstructGui() {
    this.el.selectAll("*").remove();
    this.setup();
  }

  abstract setup(): void;
}

class BoolParamEditor extends ParamEditor<Param<boolean>> {
  setup() {
    this.el
      .append("input")
      .attr("type", "checkbox")
      .attr("checked", () => (this.param.val ? "" : null))
      .on("change", (e: any) => this.setParamVal(e.target.checked));
  }
}

class StringParamEditor extends ParamEditor<Param<string>> {
  setup() {
    // TODO: input
    throw new Error("TextEditor not implemented yet!");
  }
}

class EnumParamEditor extends ParamEditor<
  EnumParam<number | number[] | string | boolean>
> {
  setup() {
    this.el
      .append("select")
      .on("change", (e: any) =>
        this.setParamVal(this.param.oneof[e.target.value])
      )
      .selectAll()
      .data(this.param.oneof)
      .enter() // for each element of this.param.oneof
      .append("option")
      .text((option) => option.toString())
      .attr("value", (_, idx) => idx)
      .attr("selected", (option) => (option === this.param.val ? "" : null));
  }
}

class NumParamEditor extends ParamEditor<NumParam> {
  setVal: this["setParamVal"];

  constructor(
    param: NumParam,
    insertLabel = true,
    setVal: NumParamEditor["setVal"] = null
  ) {
    super(param, insertLabel);
    this.setVal = setVal ?? this.setParamVal;
  }

  setup() {
  }
}

abstract class CollapsibleParamEditor<T extends Param<any>> extends ParamEditor<
  T
> {
  active: boolean;

  constructor(param: T) {
    super(param, false);
  }

  setup() {
    this.active = this.active ?? false;
    const button = this.el
      .append("button")
      .classed("accordion-button", true)
      .classed("active", this.active)
      .on("click", () => {
        // toggle "active" class - shows/hide
        this.active = !button.classed("active");
        button.classed("active", this.active);
        panel.classed("active", this.active);
      })
      .text(this.param.name);

    const panel = this.el
      .append("div")
      .classed("accordion-panel", true)
      .classed("active", this.active);

    this.setup_panel(panel);
  }

  abstract setup_panel(panel: D3Div): void;
}

class HyperParamEditor extends CollapsibleParamEditor<HyperParam> {
  setup_panel(panel: D3Div) {
  }
}

class VecParamEditor extends CollapsibleParamEditor<VecParam> {
  setup_panel(panel: D3Div) {
    const { val, name, min, max, log_scale, step } = this.param;
    for (let idx = 0; idx < this.param.val.length; idx++) {
      panel.append(() =>
        new NumParamEditor(
          {
            name: "",
            val: val[idx],
            min: min[idx],
            max: max[idx],
            log_scale,
            step,
            id: null,
          },
          false,
          (val) => {
            this.param.val[idx] = val;
            this.setParamVal(this.param.val);
          }
        ).el.node()
      );
    }
  }
}

// from msgpack docs https://github.com/msgpack/msgpack-javascript#decoding-a-blob
async function decodeFromBlob(blob: Blob) {
  return;
}

function formatNum(val: number) {
  const valStr = val.toString();
  const valAbs = Math.abs(val);
  // TODO: relate this behaviour to min and max somehow
  return valAbs > 0.001 && valAbs < 10000
    ? valStr.slice(0, 6)
    : valStr.length > 6
    ? d3.format(".2")(val)
    : valStr;
}
